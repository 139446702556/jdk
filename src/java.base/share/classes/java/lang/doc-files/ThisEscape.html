<!doctype html>
<!--
 Copyright (c) 2023, Oracle and/or its affiliates. All rights reserved.
 DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.

 This code is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License version 2 only, as
 published by the Free Software Foundation.  Oracle designates this
 particular file as subject to the "Classpath" exception as provided
 by Oracle in the LICENSE file that accompanied this code.

 This code is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 version 2 for more details (a copy is included in the LICENSE file that
 accompanied this code).

 You should have received a copy of the GNU General Public License version
 2 along with this work; if not, write to the Free Software Foundation,
 Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.

 Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 or visit www.oracle.com if you need additional information or have any
 questions.
-->
<html lang="en">
<head>
  <title>This Escape</title>
  <link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<h1 id="ThisEscape">{@index "This Escape"}</h1>

<h3>What is a "This Escape"?</h3>

<p>
The Java language requires subclass constructors to invoke a superclass constructor before
performing any other work, but superclass constructors are allowed to invoke instance methods as
part of their initialization. Therefore, if a superclass constructor invokes an instance method
that a subclass overrides, then that method will be invoked before the subclass has done any of
its own initialization, possibly leading to unexpected behavior.

<p>
The following class demonstrates the problem:
<blockquote>
<pre>
import java.util.*;
import java.util.function.*;

/**
 * A {@link Set} that only allows elements matching some {@link Predicate}.
 */
public class FilteredSet&lt;E&gt; extends HashSet&lt;E&gt; {

    private final Predicate&lt;? super E&gt; filter;

    public FilteredSet(Predicate&lt;? super E&gt; filter, Collection&lt;? extends E&gt; elems) {
        super(elems);
        this.filter = filter;
    }

    @Override
    public boolean add(E elem) {
        if (!this.filter.test(elem))
            throw new IllegalArgumentException("disallowed element");
        return super.add(elem);
    }

    public static void main(String[] args) {
        new FilteredSet&lt;&gt;(s -&gt; true, Arrays.asList("abc", "def"));  // NullPointerException
    }
}
</pre>
</blockquote>

<p>
The above example appears bug-free at first glance, but it actually throws a <code>NullPointerException</code> if run.
Moreover, how this error happens is due to a tricky interplay of three different classes:
<ol>
    <li>The <code>FilteredSet</code> constructor invokes the <code>HashSet(Collection)</code> superclass constructor;
    <li><code>HashSet(Collection)</code> constructor invokes <code>AbstractCollection.addAll()</code>;
    <li><code>AbstractCollection.addAll()</code> invokes <code>add()</code> for each element;
    <li><code>FilteredSet.add()</code> invokes <code>this.filter</code>, but that <code>this.filter</code> is still null.
</ol>

<p>
This kind of bug is due to what's called a <em>'this' escape</em>. This term refers to any time a reference to
the unitialized <code>this</code> instance "escapes" from a superclass constructor's control to some other code
before it has been fully initialized.

<p>
The example above illustrates a key difficulty with 'this' escape bugs, which is that they
typically involve an interplay among multiple source files. Inspecting any one file at a time
does not reveal the bug.

<p>
Another example of a subtle 'this' escape bug would be a superclass constructor that adds
<code>this</code> to some <code>HashSet</code>, perhaps when registering itself as a listener. If a
subclass overrides <code>hashCode()</code> to include one or more of its own fields, then the
<code>HashSet</code> will record the object under the wrong hash value, because at that time those
subclass fields won't be initialized yet.

<h3>Compiler Warnings</h3>

<p>
The Java compiler can warn about possible 'this' escapes. To enable 'this' escape detection,
include the <code>-Xlint:this-escape</code> flag on the command line.

<p>
'This' escape warnings are only reported for constructors that could be invoked by a subclass
defined in a different source file. So, for example, private constructors and constructors in
private classes will not generate warnings.

<p>
Use <code>@SuppressWarnings("this-escape")</code> to suppress this warning as needed.

<h3>Mitigation Strategies</h3>

<p>
To avoid 'this' escapes in superclasses, consider the following strategies:
<ul>
    <li>Mark initialization instance methods <code>final</code> when able
    <li>Move initialization logic into <code>static</code> methods
    <li>Mark constructors <code>private</code> when able
    <li>Mark classes <code>final</code> when able
</ul>

<p>
If a 'this' escape can't be avoided, ideally it should be documented in the constructor's API Javadoc
so that subclasses know how they can work around it.

<!-- Uncomment when JDK-8194743 is implemented
<p>
To avoid problems from 'this' escapes in subclasses, consider moving instance field initialization
to before the <code>super()</code> invocation.
-->

</body>
</html>
